# 6. 클래스
## 1. 객체 지향 프로그래밍
- 객체 지향 프로그래밍(OOP): 부품에 해당하는 객체들을 먼저 만들고, 이 객체들을 하나씩 조립해서 완성된 프로그램을 만드는 기법
### 객체란?
- 객체: 물리적으로 존재하거나 개념적인 것 중에서 다른 것과 식별 가능한 것.
  - 속성: 필드
  - 동작: 메소드
- 객체 모델링: 현실 세계 객체의 대표 속성과 동작을 추려내어 소프트웨어 객체의 필드와 메소드로 정의하는 과정(설계)
### 객체의 상호작용
- 현실 세계에서 일어나는 모든 현상은 객체와 객체 간의 상호작용으로 이루어져있음. 
- 객체 지향 프로그램에서도 객체들은 다른 객체와 서로 상호작용(수단=메소드)하며 동작: 객체가 다른 객체의 기능을 이용할때 이 메소드를 호출
- 메소드 호출을 통해 객체들은 데이터를 서로 주고 받음. 
  - `메소드(매개값1, 매개값2, ...);`: 전달하고자 하는 데이터 = 매개값
  - `타입 변수 = 메소드(매개값1, 매개값2)`: 메소드의 실행의 결과=리턴값
### 객체 간의 관계
- 집합 관계: 완성품과 부품의 관계
- 사용 관계: 다른 객체의 필드를 읽고 변경하거나 메소드를 호출하는 관계
- 상속 관계: 부모와 자식 관계(물려받음)
### 객체 지향 프로그래밍의 특징
#### 캡슐화
- 객체의 데이터(필드), 동작(메소드)을 하나로 묶고 실제 구현 내용을 외부에 감추는 것. 
- 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용
- 접근 제한자: 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지를 결정
#### 상속
- 부모 객체가 자기가 가지고 있는 필드와 메소드를 자식 객체에게 물려주어 자식 객체가 사용할 수 있게 함
  - 코드의 재사용성을 높여줌
  - 유지 보수 시간을 최소화
#### 다형성
- 사용방법은 동일하지만 실행 결과가 다양하게 나오는 성질
- 자동 타입 변환, 재정의 기술이 필요(상속+인터페이스 구현을 통해 얻어짐)
## 2. 객체와 클래스
- 객체를 생성하기 위해서 설계도에 해당하는 클래스가 필요
- 클래스로부터 생성된 객체를 해당 클래스의 인스턴스라고 부름
- 인스턴스화: 클래스로부터 객체를 만드는 과정
## 3. 클래스 선언
- 클래스 선언=객체 생성을 위한 설계도를 작성하는 작업, 필드(가져야할 데이터)와 메서드(객체의 동작)이 무엇인지 정의하는 내용 `public class 클래스명 { }`
- 하나의 소스 파일은 복수 개의 클래스 선언을 포함 가능 -> 복수 개의 클래스 선언이 포함된 소스 파일을 컴파일하면 클래스 선언 수만큼의 바이트코드 파일이 생김.
  - 하나의 소스 파일에 복수 개의 클래스를 선언 시 소스 파일명과 동일한 클래스만 공개 클래스(public)로 선언 가능.
## 4. 객체 생성과 클래스 변수
- 클래스로부터 객체를 생성 시 객체 생성 연산자 **new**가 필요.
  - `클래스 변수 = new 클래스()`: 생성자 호출 코드(클래스()) + new연산자: 객체 생성 후 객체 주소 리턴 -> 클래스 변수에 대입 가능
  - 스택 영역에 생긴 클래스 변수가 생성된 객체의 주소를 가지고 힙 영역에 생성된 객체를 참조하는 형태
- 클래스의 두 가지 용도
  - 라이브러리(library) 클래스: 실행 불가, 다른 클래스에서 이용하는 클래스
  - 실행 클래스: main() 메소드를 가지고 있는 실행 가능한 클래스
## 5. 클래스의 구성 멤버
- 클래스 선언: 객체 초기화 역할을 담당하는 생성자 + 객체에 포함될 필드, 메소드 선언
- 클래스 구성 멤버
  - 필드: 객체의 데이터를 저장하는 역할(~=변수 선언과 형태는 비슷; 쓰임새는 다름)
  - 생성자: new 연산자로 객체를 생성할 때 객체의 초기화 역할 담당, 선언 형태는 메소드와 비슷하지만 리턴 타입이 없고 클래스 이름과 동일한 이름.
  - 메소드: 객체가 수행할 동작(=함수라고 부르기도 하지만 객체 내부의 함수는 메소드라고 부름), 객체와 객체 간의 상호 작용을 위해 호출됨
## 6. 필드 선언과 사용
- 객체의 데이터(고유 데이터, 현재 상태 데이터, 부품 데이터)를 저장
### 필드 선언
- 변수를 선언하는 방법과 동일하지만 클래스 블록에서 선언해야함.
- `타입 필드명 [ = 초기값]`
> 필드와 (로컬)변수의 차이점
> - (로컬)변수: 생성자와 메소드 블록에서 선언, 생성자와 메소드 호출시에만 생성 및 사용됨
> - 필드: 클래스 블록에서 선언, 객체 내부에 존재, 객체 내외부에서 사용 가능.
- 타입: 필드에 저장할 데이터의 종류(기본타입 + 참조타입)
- 필드명: 첫 문자를 소문자로 하되 캐멀 스타일로 작성하는 것이 관례
- 초기값을 제공하지 않을 경우 객체 생성 시 자동으로 기본값으로 초기화됨.(0, flase, null)
### 필드 사용
- 필드를 사용한다는 것 = 필드값을 읽고 변경하는 것
- 클래스에서 선언 후 객체를 생성해야 사용 가능
- 객체 내부의 생성자와 메소드 내부에서 사용 가능(필드명 사용), 객체 외부에서도 접근해서 사용 가능(참조 변수와 도트 연산자-객체 접근 연산자-를 이용)
## 7. 생성자 선언과 호출
- new 연산자: 객체를 생성한 후 연이어 생성자를 호출해서 객체를 초기화하는 역할, 생성자의 실행이 끝나면 객체의 주소를 리턴
  - 객체 초기화: 필드 초기화, 메소드를 호출해서 객체를 사용할 준비를 하는 것.
### 기본 생성자
- 모든 클래스는 생성자가 존재, 하나 이상을 가질 수 있음
- 클래스에 생성자 선언이 없으면 컴파일러는 기본 생성자를 바이트코드 파일에 자동으로 추가시킴
  - 기본 생성자: `[public] 클래스() { }`
  - 클래스가 public class인 경우 기본 생성자에도 public이 붙음
  - 클래스가 class로만 선언된 경우 기본 생성자에도 public이 붙지 않음.
- 개발자가 명시적으로 선언한 생성자가 있다면 컴파일러는 기본 생성자를 추가하지 않음
### 생성자 선언
- 객체를 다양하게 초기화하기 위해 생성자를 직접 선언
- `클래스(매개변수, ...) { //객체의 초기화 코드 }`
- 생성자는 메소드와 비슷한 모양을 가지고 있으나, **리턴 타입이 없고** 클래스 이름과 동일.
- 매개변수: new 연산자로 생성자를 호출할 때 매개값 생성자 블록 내부로 전달하는 역할.
- 매개변수의 타입은 매개값의 종류에 맞게 작성
### 필드 초기화
- 객체마다 동일한 값을 갖고 있다면 필드 선언 시 초기값을 대입하는 것이 좋고, 객체마다 다른 값을 가져야한다면 생성자에서 필드를 초기화.
- 생성자의 매개값은 new 연산자로 생성자를 호출할 때 주어짐.
### 생성자 오버로딩
- 매개값으로 객체의 필드를 다양하게 초기화하려면 생성자 오버로딩(매개변수를 달리하는-타입, 개수, 순서- 생성자를 여러 개 선언하는 것)이 필요.(매개변수 이름만 바꾸는 것은 생성자 오버로딩이 아님)
- 생성자가 오버로딩되어 있을 경우, new 연산자로 생성자를 호출할때 제공되는 매개값의 타입과 수에 따라 실행될 생성자가 결정                           
### 다른 생성자 호출
- 생성자 오버로딩이 많아져서 중복 코드가 많이 발생하는 경우(매개변수의 수만 다르고 필드 초기화 내용이 비슷한 경우) -> 공통 코드를 한 생성자에만 집중적으로 작성, 나머지 생성자는 this(매개값, ...)를 생성자의 첫 줄에 작성하여 다른 생성자를 호출 -> 호출되는 생성자의 실행이 끝나면 원래 생성자로 돌아와서 다음 실행문을 실행.
## 8. 메소드 선언과 호출
- 메소드 선언: 객체의 동작을 실행 블록으로 정의하는 것
- 메소드 호출: 실행 블록을 실제로 실행하는 것
- 메소드는 객체 내외부에서 호출될 수 있기 때문에 객체 간의 상호작용하는 방법을 정의하는 것.
### 메소드 선언
- `리턴타입 메소드명 (매개변수, ...) { //실행코드작성 }`
#### 리턴 타입
- 메소드가 실행한 후 호출한 곳으로 전달하는 결과값의 타입
- 리턴값이 없는 메소드는 void로 작성
- 리턴 타입이 있는 메소드는 실행 블록 안에서 return문으로 리턴값을 지정해야함.
#### 메소드명
- 첫 문자를 소문자로 시작
- 캐멀 스타일
#### 매개변수
- 메소드를 호출할 때 전달한 매개값을 받기 위해 사용
- 전달할 매개값이 없다면 생략 가능
#### 실행 블록
- 메소드 호출 시 실행되는 부분
### 메소드 호출
- 메소드 호출 = 메소드 블록 실행
- 메소드 선언 후 객체가 생성되었을때 메소드 호출 가능(메소드는 객체의 동작이므로)
  - 객체 내부: 메소드명
  - 객체 외부: 참조 변수와 도트연산자(.), 매개변수의 타입과 수에 맞게 매개값 제공, 리턴값이 있을 경우에 대입 연산자를 통해 변수에 저장 가능
#### 가변길이 매개변수
- 메소드 호출 시 매개변수의 개수에 맞게 매개값을 제공해야함. -> **가변길이 매개변수**를 가지고 있다면 매개변수의 개수와 상관없이 매개값을 줄 수 있음
- 가변길이 매개변수의 선언: `int sum(int ... values)`
- 가변길이 매개변수 전달: `int result = sum(1, 2, 3);`, `int result = sum(1, 2, 3, 4, 5);`
  - 매개값들은 자동으로 배열 항목으로 변환되어 메소드에서 사용 -> 메소드 호출시 배열을 직접 매개값을 제공 가능.
    - `int[] values = {1, 2, 3}; int result = sum(values);` or `int result = sum(new int[] {1, 2, 3});`
#### return 문
- return문: 메소드의 실행을 강제 종료, 호출한 곳으로 돌아간다는 의미
- 메소드 선언에 리턴 타입이 있을 경우, return문 뒤에 리턴값을 추가로 지정해야함.
- Unreachable code: return문 이후에 실행문을 작성하면 발생하는 컴파일 에러
#### 메소드 오버로딩
- 메소드 이름은 같음; 매개변수의 타입, 개수, 순서가 다른 메소드를 여러 개 선언하는 것; 리턴 타입은 무관
- 목적: 다양한 매개값 처리를 위해서(다양한 타입 지원 등)
  - 대표적인 예: `System.out.println()`-호출 시 주어진 매개값의 타입에 따라서 오버로딩된 메소드 중 하나를 실행
## 9. 인스턴스 멤버
- 필드와 메소드는 선언 방법에 따라 구분: 인스턴스 멤버 & 정적 멤버
### 인스턴스 멤버 선언 및 사용
- 인스턴스 멤버: 객체에 소속된 멤버, 객체가 있어야만 사용 가능한 멤버
  - 필드는 객체마다 따로 존재(소속o, 포함o)
  - 메소드는 각 객체마다 존재하지 않고 메소드 영역에 저장 및 공유됨(소속o, 포함x).
### this 키워드
- 객체 내부에서 인스턴스 멤버에 접근하기 위해 this를 사용
- 생성자와 메소드의 매개변수명이 인스턴스 멤버인 필드명과 동일한 경우, 인스턴스 필드임을 강조하고자 할 때 사용
## 10. 정적 멤버
- 클래스 로더를 이용해서 클래스를 메소드 영역에 저장 후 사용
- 정적 멤버: 메소드 영역의 클래스에 고정적으로 위치하는 멤버 -> 객체 생성할 필요 없이 클래스를 통해 바로 사용 가능
### 정적 멤버 선언
- 정적 필드, 정적 메소드로 선언하려면 **static 키워드**를 추가하면 됨.
```java
public class 클래스이름 {
  static 타입 필드 [=초기값];
  static 리턴타입 메소드(매개변수, ...) { ... };
}
```
- 정적 멤버의 예
  - 객체마다 가지고 있을 필요성이 없는 공용적인 필드
  - 인스턴스 필드를 이용하지 않는(외부에서 주어지는 매개값을 이용하는 등) 메소드
### 정적 멤버 사용
- 클래스가 메모리로 로딩되면, 클래스 이름과 함께 도트(.) 연산자로 접근 가능
  - 객체 참조 변수로도 접근 가능하지만 클래스 이름으로 접근하는 것이 정석
### 정적 블록
- 정적 필드는 필드 선언과 동시에 초기값을 주는 것이 일반적.
  - 복잡한 초기화 작업이 필요할 시 정적 블록을 이용 `static { ... }`
- 정적 블록은 클래스가 메모리로 로딩될 때 자동으로 실행, (여러 개가 있을 경우 선언된 순서대로 실행)
> 정적 필드는 객체 생성 없이도 사용 가능 -> 생성자에서 초기화하지 않음
### 인스턴스 멤버 사용 불가
- 정적메소드/블록: 객체가 없어도 실행됨 
  - 인스턴스 필드나 인스턴스 메소드 사용 불가
  - 객체 자신의 참조인 this 사용 불가
- 인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성하고 참조 변수로 접근해야함.
  - main() 메소드도 동일한 규칙 적용
## 11. final 필드와 상수
- 인스턴스 필드와 정적 필드는 언제든지 값을 변경 가능 -> 변경을 막고 읽기만 허용해야할 때 final필드와 상수를 선언하여 사용
### final 필드 선언
- final 필드는 초기값이 저장되면 최종적인 값으로 지정해 프로그램 실행 도중 수정할 수 없게 됨.
- `final 타입 필드 [=초기값];`
- final 필드에 초기값을 줄 수 있는 방법
  1. 필드 선언 시에 초기값 대입 - 고정된 값
  2. 생성자에서 초기값 대입 - 복잡한 초기화 코드가 필요/객체 생성 시에 외부에서 전달된 값으로 초기화할 필요
### 상수 선언
- 상수: 불변의 값을 저장하는 필드
- 상수는 객체마다 저장할 필요x, 여러 개의 값을 가져도 안되기 때문 -> static, final인 특성
- `static final 타입 상수 [=초기값];`: 초기값은 선언 시에 주는 것이 일반적
- 정적 블록에서도 초기화 가능
```java
static final 타입 상수;
static {
    상수 = 초기값;
}
```
- 상수 이름은 모두 대문자로 작성하는 것이 관례, 서로 다른 단어가 혼합된 이름->언더바(_)로 연결
- 상수는 정적 필드이므로 클래스로 접근해서 읽을 수 있음.
## 12. 패키지
- 자바의 패키지: 단순히 디렉토리만을 의미하지는 않음. 패키지는 클래스의 일부분, 클래스를 식별하는 용도로 사용 -> 클래스의 전체 이름에 포함됨.
  - 패키지는 주로 개발 회사의 도메인 이름의 역순으로 만듦.
  - 상위 패키지와 하위 패키지를 도트(.)로 구분.
  - 패키지에 속한 바이트코드 파일(~.class)은 따로 떼어내어 다른 디렉토리로 이동할 수 없음.
### 패키지 선언
- 컴파일러는 클래스의 패키지 선언을 보고 디렉토리를 자동 생성시킴. 
  - `package 상위패키지.하위패키지`, `public class 클래스명 { ... }`
- 패키지 이름
  - 패키지 이름은 모두 소문자로 작성하는 것이 관례
  - 패키지 이름이 서로 중복되지 않도록 회사 도메인 이름의 역순으로 작성
  - 마지막에 프로젝트 이름을 붙여주는 것이 일반적
- 이클립스/vscode: 패키지를 먼저 생성하고 클래스를 나중에 추가하는 방식.
  - 패키지 선언이 없다면 이클립스는 클래스를 default package에 포함시킴.
### import 문
- 같은 패키지 안에 있는 클래스는 아무런 조건 없이 사용 가능하지만, 다른 패키지에 있는 클래스를 사용하려면 import문을 이용해 어떤 패키지의 클래스를 사용하는지 명시해야함.
- 패키지 선언과 클래스 선언 사이에 import문이 작성됨.
- import 키워드 뒤에는 사용하고자하는 클래스의 전체 이름을 기술. 동일한 패키지에 포함된 다수의 클래스를 사용할 때는 클래스 이름을 생략하고 *를 사용.
- import문은 하위 패키지를 포함하지 않음. 별도의 import문이 필요함.
- 서로 다른 패키지에 동일한 클래스 이름이 존재 -> 클래스의 전체 이름을 사용해서 어떤 패키지의 클래스를 사용하는지 알려야함. -> import문은 필요 없다.
## 13. 접근 제한자
- 경우에 따라서는 객체의 필드를 외부에서 변경하거나 메소드를 호출할 수 없도록 막아야할 필요o -> 무결성 유지
- 접근 제한자
  - public: 클래스, 필드, 생성자, 메소드(제한범위 없음)
  - protected: 필드, 생성자, 메소드(같은 패키지이거나, 자식 객체만 사용 가능)
  - (default): 클래스, 생성자, 메소드(같은 패키지)
  - private: 필드, 생성자, 메소드(객체 내부)
### 클래스의 접근 제한
- 클래스 선언 시, public 접근 제한자를 생략했다면 default 접근 제한을 가짐.(같은 패키지 내에서만 제한 없이 사용 가능)
- 클래스 선언 시, public 접근 제한자를 붙였다면 public 접근 제한을 가짐.(다른 패키지에서도 사용 가능)
### 생성자의 접근 제한
- 객체 생성 시 생성자를 어디에서나 호출 가능한 것은 아님. 생성자의 접근제한자에 따라 호출 가능여부가 결정됨.
  - `public 클래스(...) { }`: 모든 패키지에서 생성자 호출 가능(=객체 생성 가능)
  - `클래스(...) { }`: 같은 패키지에서만 생성자 호출 가능(=객체 생성 가능)
  - `private 클래스(...) { }`: 클래스 내부에서만 생성자 호출 가능(=객체 생성 가능)
### 필드와 메소드의 접근 제한
- 필드/메소드 역시 어떤 제한 접근을 갖느냐에 따라 호출 여부가 결정됨
  - `public 필드`: 모든 패키지에서 필드를 읽고 변경 가능
  - `public 메소드(...) { }`: 모든 패키지에서 메소드를 호출 가능
  - `필드`: 같은 패키지에서만 필드를 읽고 변경 가능
  - `메소드(...) { }`: 같은 패키지에서만 메소드를 호출 가능
  - `private 필드`: 클래스 내부에서만 필드를 읽고 변경 가능
  - `private 메소드(...) { }`: 클래스 내부에서만 메소드를 호출 가능
## 14. Getter와 Setter
- 객체의 필드(데이터)를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성이 깨질 수 있음.
  - 직접적인 외부에서의 필드 접근을 막고 메소드를 통해 데이터를 검증 후 필드에 접근하는 것을 선호
  - 외부에서 객체의 필드를 읽을 때 메소드가 필요한 경우: 필드값이 객체 외부에서 사용하기에 부적절한 경우, 메소드로 적절한 값으로 변환하여 리턴 가능.
- Getter & Setter: Get/Set + 필드이름(첫글자 대문자)
```java
private 타입 fieldName;
//Getter
public 타입 getFieldName() {
    return fieldName;
}
//Setter
public void setFieldName(타입 fieldName) {
    this.fieldName = fieldName;
}

//필드 타입이 boolean일 경우 Getter은 is로 시작하는 것이 관례
private boolean stop;
//Getter
public boolean isStop() {
    return stop;
}
```
## 15. 싱글톤 패턴
- 애플리케이션 전체에서 단 한개의 객체만 생성해 사용하고 싶을 때 적용
- 생성자를 private 접근 제한해서 외부에서 new 연산자로 생성자를 호출할 수 없도록 막음
- 외부에서 마음대로 객체를 생성할 수 없음; 싱글톤 패턴이 제공하는 정적 메소드를 통해 간접적으로 객체를 얻을 수 있음.
```java
public class 클래스 {
    private static 클래스 singleton = new 클래스(); //private 접근 권한을 갖는 정적 필드(=객체 변수 singleton) 선언과 초기화
    private 클래스() {} //private 접근 권한을 갖는 생성자 선언
    public static 클래스 getInstance() {
        return singleton;
    } //public 접근 권한을 갖는 정적 메소드 선언, 외부에서 객체를 얻는 유일한 방법
}
클래스 변수1 = 클래스.getInstance(); 
클래스 변수2 = 클래스.getInstance(); //두 변수가 참조하는 객체는 동일한 싱글톤 객체가 됨.
```
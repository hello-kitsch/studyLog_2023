# 5. 참조 타입
## 1. 데이터 타입 분류
- 기본 타입(primitive type): 정수타입(byte, char, short, int, long), 실수타입(float, double), 논리타입(boolean)
- 참조 타입(reference type): 배열타입, 열거타입, 클래스, 인터페이스
  - 객체의 번지를 참조하는 타입
  > 객체: 데이터(필드) + 메소드
- 기본 타입 vs 참조 타입: 저장되는 값(값 자체 vs 객체가 생성된 메모리 번지)
- 변수들은 모두 스택이라는 메모리 영역에 생성됨. 참조 타입 변수는 힙 메모리 영역의 객체의 주소 번지를 저장
## 2. 메모리 사용 영역
- java 명령어로 JVM 구동 -> 운영체제에서 할당받은 메모리 영역(Runtime Data Area)을 구분하여 사용
  - 메소드 영역
    - 바이트코드 파일을 읽은 내용이 저장되는 영역
    - 클래스별로 상수, 정적 필드, 메소드 코드, 생성자 코드 등이 저장됨
  - 힙 영역
    - 객체가 생성되는 영역
    - 객체의 번지는 메소드 영역과 스택 영역의 상수와 변수에서 참조 가능
  - 스택 영역(스레드 안에 담겨있음)
    - 메소드를 호출할 때마다 생성되는 프레임이 저장되는 영역, 메소드 호출이 끝나면 프레임은 자동 제거됨. 
    - 프레임 내부에는 로컬 변수 스택이 있음(기본 타입 변수, 참조 타입 변수가 생성되고 제거됨)
## 3. 참조 타입 변수의 ==, != 연산
- ==, != 연산자는 변수의 값이 같은지 아닌지를 조사. 
- 참조 타입 변수의 ==, != 연산자는 번지(동일한 객체인가)를 비교하는 것.
## 4. null과 NullPointerException
- 참조 타입 변수는 아직 번지를 저장하고 있지 않다는 뜻으로 null 값을 가질 수 있음(초기값 사용 가능)
- 참조 변수를 사용하면서 가장 많이 발생하는 예외(프로그램 실행 도중에 발생하는 오류): NullPointerException
  - 참조 변수가 null인 상태에서 객체의 데이터나 메소드를 사용하려 할 때 해당 예외가 발생
  - 프로그램에서 객체를 사용하지 못하게 하려고 참조 변수에 null을 대입 
  > - 어떤 변수에서도 객체를 참조하지 않으면 해당 객체는 프로그램에서 사용할 수 없는 객체가 됨 -> Garbage Collector가 자동 제거함.
  > - 자바는 코드를 이용해 객체를 직접 제거하는 방법을 제공하지 않음. 유일한 방법=객체의 모든 참조를 없애는 것.
## 5. 문자열(String) 타입
- 자바의 문자열은 String 객체로 생성됨. 
- String 변수에 **문자열 리터럴**이 대입되면 String 객체로 생성되고 객체의 번지가 각각 대입됨. ->1번 방법
### 문자열 비교
- 문자열 리터럴이 동일하다면 String 객체를 공유하도록 설계되어 있음.
- **new 연산자**(객체 생성 연산자)로 직접 String 객체를 생성 후 대입 가능 -> 2번 방법
  - 이 경우 서로 다른 String 객체의 번지를 가지게 됨.
- 비교 연산
  - ==: 객체 자체의 비교
  - String 객체의 equals(): 내부 문자열만을 비교
- String 변수에 빈 문자열(String 객체) 대입 가능 -> 변수가 빈 문자열을 참조하는지 조사하려면 equals() 메서드 사용
### 문자 추출
- charAt(): 문자열에서 특정 위치의 문자를 얻고 싶을 때, 매개값으로 주어진 인덱스(0 ~ 문자열-1)의 문자를 리턴
### 문자열 길이
- length(): 문자열에서 문자의 개수를 얻고 싶을 때(공백 포함)
### 문자열 대체
- replace(): 문자열에서 특정 문자열을 다른 문자열로 대체하고 싶을 때, 기존 문자열을 그대로 두고, 대체한 새로운 문자열을 리턴 (String 객체의 문자열은 변경이 불가한 특성)
  - 첫번째 인수: 기존 문자열에서 대체할 부분, 두번째 인수: 대체할 새로운 문자열
### 문자열 잘라내기
- substring(): 문자열에서 특정 위치의 문자열을 잘라내어 가져오고 싶을 때 사용
  - substring(int beginIndex): beginIndex에서 끝까지 잘라내기
  - substring(int beginIndex, int endIndex): beginIndex에서 endIndex 앞까지 잘라내기
### 문자열 찾기
- indexOf(): 문자열에서 특정 문자열의 위치를 찾고자 할 떄 사용
  - 주어진 문자열이 시작되는 인덱스를 리턴.
  - 주어진 문자열이 포함되어 있지 않으면 -1을 리턴.
- contain(): 주어진 문자열이 단순히 포함되어 있는지만 조사하고 싶을때 사용-boolean 값 리턴
### 문자열 분리
- split(): 문자열이 구분자를 사용하여 여러 개의 문자열로 구성되어 있을 경우, 분리해서 얻고 싶을 경우 사용
  - 분리된 문자열로 구성된 배열을 반환
## 6. 배열(Array) 타입
- 변수는 하나의 값만 저장 -> 많은 변수가 필요해질 때 불필요한 선언을 줄이면서 값을 다루는 방법 = 배열
- 배열: 연속된 공간에 값을 나열, 각 값에 인덱스를 부여해놓은 자료구조.
  - 배열은 같은 타입의 값만 관리
  - 배열의 길이는 늘이거나 줄일 수 없다.
### 배열 변수 선언
- `타입[] 변수`, `타입 변수[]` (첫번째 방법을 관례적으로 주로 사용)
- 배열 변수는 **참조 변수**: 배열도 객체->힙 영역에 생성, 배열 변수는 힙 영역의 배열 주소를 저장, null값으로 초기화 가능(이 상태에서 값을 읽게 되면 NullPointerException 발생)
### 값 목록으로 배열 생성
- `타입[] 변수 = { 값0, 값1, 값2, ... }`: 중괄호 {}는 나열된 값들을 항목으로 가지는 배열을 힙에 생성 후 번지 리턴, 배열 변수는 리턴된 번지를 저장함으로써 참조가 이루어짐.
- 배열 변수를 미리 선언한 경우, 중괄호 {}로 감싼 값의 목록을 배열 변수에 대입할 수 없음.
  - 대입하고 싶다면 `변수 = new 타입[] { 값0, 값1, 값2, 값3, ... };`와 같이 new 타입[]을 붙여줘야함.
  - 메소드의 매개변수가 배열 타입인 경우: 호출 시 중괄호 {}로 감싼 값 목록을 전달하면 컴파일 에러 발생
    - 메소드 선언: `void printItem(int[] scores) {...}`
    - 메소드 호출(컴파일 에러): `printItem( {95, 85, 90} );`
    - 올바른 메소드 호출: `printItem( new int[] {95, 98, 90} );`
### new 연산자로 배열 생성
- 값의 목록은 없지만 향후 값들을 저장할 목적으로 배열을 미리 생성. 
- `타입[] 변수 = new 타입[길이]`
- new 연산자: 해당 길이의 배열을 생성, 배열의 번지를 리턴 -> 배열 변수에 대입 가능(이미 선언된 후에도 대입 가능)
- new 연산자로 배열을 처음 생성시 배열 항목은 기본값으로 초기화됨
  - byte[]: 0
  - char[]: '\u0000'
  - short[]: 0
  - int[]: 0
  - long[]: 0L
  - float[]: 0.0F
  - double[]: 0.0
  - boolean[]: false
  - 클래스[]: null
  - 인터페이스[]: null
- 배열 생성 후 특정 인덱스 항목을 새로운 값으로 변경하는 방법: `변수[인덱스] = 값`
### 배열 길이
- 배열에 저장할 수 있는 항목 수
- 배열의 길이를 얻는 법: .연산자를 사용해 참조하는 배열의 length 필드를 읽기
  - 값을 변경할 수는 없음
  - for문을 사용해 전체 배열 항목을 반복할 때 많이 사용
## 7. 다차원 배열
- 다차원 배열: 배열 항목에 또 다른 배열이 대입 (1차원 배열을 서로 연결한 것)
- `변수[1차원인덱스][2차원인덱스]...[N차원인덱스]`
### 값 목록으로 다차원 배열 생성
- 배열 변수 선언시 타입 뒤에 대괄호 []를 차원의 수만큼 붙이고, 값 목록도 차원의 수만큼 중괄호를 중첩시키기.(1차원 배열의 서로 다른 인덱스에 2차원 배열을 넣을 때 각각의 크기가 달라도 무관함)
- 각 차원의 배열에 length 필드로 크기를 알아낼 수 있음
### new 연산자로 다차원 배열 생성
- `타입[][] 변수 = new 타입[1차원수][2차원수]`: 변수 선언 시 타입 뒤 대괄호 []를 차원의 수만큼 붙이기 + new 타입 뒤에도 대괄호 []를 차원수의 만큼 붙이기
- 마지막 차원의 배열의 값은 초깃값을 가짐 (정수타입-0, 실수타입-0.0, 논리타입-false, 참조타입-null)
- 2차원 배열의 길이를 다르게 주는 방법: 1차원 배열의 길이만 명시하여 배열 객체를 우선 생성 후 각각의 인덱스 값으로 길이가 다른 2차원 배열을 대입하면 됨.
  - `int[][] scores = new int[2][];`
  - `scores[0] = new int[3];`
  - `scores[1] = new int[2];`
## 8. 객체를 참조하는 배열
- 기본 타입 배열은 각 항목에 값을 직접 저장;
- 참조 타입(클래스, 인터페이스) 배열은 각 항목에 객체의 번지를 저장.
- ==, != 연산자를 배열 항목이 참조하는 객체가 같은 객체인지 확인
  - equals() 메서드: 객체 내부의 값(문자열)만 비교할 때
## 9. 배열 복사
- 배열은 한번 생성하면 길이를 변경할 수 없음 -> 더 많은 저장 공간이 필요하다면 더 큰 길이의 배열을 새로 만들고 이전 배열로부터 항목들을 복사해야 함.
- 배열 복사를 위한 메소드: `System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);`
## 10. 배열 항목 반복을 위한 향상된 for문
- 자바는 배열 및 컬렉션을 쉽게 처리할 목적으로 변형된 for문을 제공
- `for(2.타입변수; 1.배열) { 3.실행문 }`: 카운터 변수와 증감식을 사용하지 않음.
  - 배열에서 가져올 항목이 있을 경우(없을 때는 for문 종료)->타입 변수에 저장->실행문 실행->배열로 되돌아감.
## 11. main() 메소드의 String[] 매개변수 용도
- main() 메소드의 인자로 문자열 배열 형태인 String[] args 매개변수가 필요한 이유
  - 터미널에서 프로그램 실행 시 요구하는 값이 있는 경우: 값들이 문자열로 취급되어 String[] 배열(args)의 항목값으로 구성됨.
  - main() 메소드 안에서 입력값을 얻는 방법: `String x = args[0];`, `String y = args[1];` 
  - main() 메소드 안에서 타입변환하는 방법: `int x = Integer.parseInt(args[0]);`, `int y = Integer.parseInt(args[1]);`
  - 실행 시 몇 개의 값이 입력되었는지 확인: `if(args.length != 2) { System.out.println("실행 시 두 개의 값이 필요합니다.");}`
## 12. 열거(Enum) 타입
- 열거 타입: 몇 가지로 한정된 값을 갖는 데이터의 타입 
  - 열거 타입 이름(첫 문자는 대문자, 캐멀 스타일)으로 소스파일을 생성하고 한정된 값을 코드로 정의
- 열거 상수: 열거 타입으로 사용할 수 있는 한정된 값
  - 알파벳으로 정의, 대문자로 작성
  - 여러 단어로 구성될 경우에는 언더바로 연결하는 것이 관례.
- 열거 타입도 하나의 데이터 타입 -> 변수를 선언하고 사용 -> 변수에 열거 상수를 대입 가능 `[열거타입] [변수] = [열거타입].[열거상수]`
- 열거 타입 = 참조 타입 -> null을 대입 가능
- ==, != 연산자를 사용 가능
- Calendar 클래스: 컴퓨터의 날짜, 요일, 시간을 얻을 때 이용
```java
Calendar now = Calendar.getInstance();
int year = now.get(Calendar.YEAR);
int month = now.get(Calendar.MONTH) + 1;
int day = now.get(Calendar.DAY_OF_MONTH);
int week = now.get(Calendar.DAY_OF_WEEK);
int hour = now.get(Calendar.HOUR);
int minute = now.get(Calendar.MINUTE);
int second = noew.get(Calendar.SECOND);
```
> 의문점: Calendar는 클래스(get()메서드를 가지는 클래스)이면서 열거타입이 될 수 있는건가? 
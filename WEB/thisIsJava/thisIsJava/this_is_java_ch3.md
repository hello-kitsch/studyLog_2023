# 3. 연산자
## 1. 부호/증감 연산자
- +(피연산자): 피연산자의 부호 유지
- -(피연산자): 피연산자의 부호 변경 
  - 변수값의 부호를 변경할 때 사용, 부호 변경 후의 타입에 주의
    - 정수 타입(byte, short, int) 연산의 결과는 int 타입
- 증감 연산자: 변수의 값을 1 증가시키거나 1 감소시키는 연산자
  - ++(피연산자): 피연산자의 값을 1 증가시킴
  - --(피연산자): 피연산자의 값을 1 감소시킴
  - (피연산자)++: 다른 연산을 수행한 후에 피연산자의 값을 1 증가시킴
  - (피연산자)--: 다른 연산을 수행한 후에 피연산자의 값을 1 감소시킴
  - 변수 단독으로 증감 연산자를 사용 시 결과는 동일하지만, 여러 개의 연산자가 포함되어 있는 연산식에서는 증감 연산자의 위치에 따라 결과가 달라짐.
## 2. 산술 연산자
- (피연산자)+(피연산자): 덧셈 연산
- (피연산자)-(피연산자): 뺄셈 연산
- (피연산자)*(피연산자): 곱셈 연산
- (피연산자)/(피연산자): 나눗셈 연산
- (피연산자)%(피연산자): 나눗셈의 나머지를 산출하는 연산
- 산술 연산의 특징
  - 피연산자가 정수타입(byte, short, char, int) -> 연산의 결과는 int 타입
  - 피연산자가 정수 타입, 그 중 하나가 long 타입 -> 연산의 결과는 long 타입
  - 피연산자 중 하나가 실수 타입 -> 연산의 결과는 실수 타입
## 3. 오버플로우와 언더플로우
- 오버플로우: 타입이 허용하는 최대값을 벗어나는 것
- 언더플로우: 타입이 허용하는 최소값을 벗어나는 것
- 정수 타입 연산에서 오버플로우/언더플로우가 발생 시 각 정수 타입의 최소값/최대값으로 되돌아감
  - byte 타입의 경우
    - -128에서 1을 빼면 127으로 돌아감
    - 127에서 1을 더하면 -128로 돌아감
- 연산 과정 중에 발생하는 오버/언더플로우는 우리가 기대하는 값이 아니므로 항상 해당 타입의 범위 내에서 연산이 수행되도록 신경써야함.
## 4. 정확한 계산은 정수 연산으로
- 산술 연산을 정확하게 계산하고 싶다면 실수 타입을 사용하지 않는 것이 좋음
  - 부동 소수점 방식을 사용하기 때문.\
## 5. 나눗셈 연산 후 NaN과 Infinity 처리
- ArithmeticException: 나눗셈(/) 또는 나머지(%) 연산에서 좌측 피연산자가 정수, 우측 피연산자가 0일 경우 발생하는 예외(무한대의 값을 정수로 표현 불가능하기 때문)
- 한쪽 연산자가 실수(0.0, 0.0f을 포함)라면 Infinity 또는 NaN이 됨.
- /와 % 연산의 결과를 확인 후 연산 수행(isInfinity(), isNaN())
## 6. 비교 연산자
- 동등(==, !=), 크기(<,<=,>,>=)를 평가하여 boolean 타입인 true/false를 산출
- 흐름 제어문(조건문, 반복문)에서 주로 사용
- 피연산자의 타입이 서로 다를 경우에 비교 연산을 수행하기 전에 타입을 일치시킴.
  - 예외 `0.1f == 0.1 //false`: 부동 소수점 방식을 사용하므로 double 타입으로 변환될때 정밀도 차이로 인해 값이 달라짐 
  - 해결책 `0.1f == (float) 0.1 //true`: 피연산자를 float 타입으로 강제 타입 변환 후 비교 연산
- 문자열 비교시 동등 연산자가 아닌 equals(), ! equals()를 사용
## 7. 논리 연산자
- 흐름 제어문(조건문, 반복문)등에서 주로 이용됨
- AND(&& 또는 &): 논리곱, 피연산자 모두가 true일 경우에만 연산 결과가 true
  - &&: 피연산자가 false라면 뒤의 피연산자를 평가하지 않고 바로 false를 산출
  - &: 두 피연산자 모두를 평가해서 산출 결과를 냄
- OR(|| 또는 |): 논리합, 피연산자 중 하나만 true이면 연산 결과는 true
  - ||: 피연산자가 true라면 뒤의 피연산자를 평가하지 않고 바로 true를 산출
  - |: 두 피연산자 모두를 평가해서 산출 결과를 냄
- XOR(^): 피연산자가 하나는 true이고 다른 하나가 false일 경우에만 연산결과가 true
- NOT(!): 피연산자의 논리값을 바꿈
## 8. 비트 논리 연산자
- bit 단위로 논리 연산을 수행(피연산자가 0과 1)
  - 2진수 0과 1로 저장되는 정수타입(byte, short, int, long)만 피연산자가 될 수 있음
  - 부동 소수점 방식으로 저장되는 실수 타입(float, double)은 피연산자가 될 수 없음
- true(1), false(0)
  - AND(&): 두 비트 모두 1일 경우에만 연산 결과가 1
  - OR(|): 두 비트 중 하나만 1이면 연산 결과는 1
  - XOR(^): 두 비트가 서로 다를 경우에만 1
  - NOT(~): 보수
- 비트 논리 연산자는 int 타입으로 자동 변환한 후 연산을 수행 -> 연산 결과도 int 타입
- C프로그램의 unit8_t 타입의 변수(1byte)를 java의 byte 타입의 변수에 저장할 때 byte의 범위 최대값과 자바가 읽은 값의 논리곱 연산을 수행하면 원래 값이 복원됨. 
> WHY? 범위 최대값 = 모든 비트가 1, 1과 AND연산을 한다는 건 무슨 의미? 부호 때문에 바뀐 비트를 되돌려놓음(1&0=0)
  - 위의 과정을 수행하는 코드: Byte.toUnsignedInt()
## 9. 비트 이동 연산자
- 비트 연산자: 이동 연산자(비트를 좌측 또는 우측으로 밀어서 이동시키는 연산을 수행)
- a << b: 정수 a의 각 비트를 b만큼 왼쪽으로 이동, 오른쪽 빈자리는 0으로 채움($a\times 2^b$)
- a \>\> b: 정수 a의 각 비트를 b만큼 오른쪽으로 이동, 왼쪽 빈자리는 최상위 부호 비트와 같은 값으로 채움($a/2^b$)
- a \>\>\> b: 정수 a의 각 비트를 b만큼 오른쪽으로 이동, 왼쪽 빈자리는 0으로 채움
## 10. 대입 연산자
- 대입 연산자는 우측 피연산자(리터럴, 변수, 다른 연산식)의 값을 좌측 피연산자인 변수에 대입
  - 단순 대입 연산자: 단순히 값을 대입
  - 복합 대입 연산자: 정해진 연산을 수행한 후 결과를 대입
- =: 우측의 피연산자의 값을 변수에 저장
- +=: 우측의 피연산자의 값을 변수의 값과 더한 후에 다시 변수에 저장
- -=: 우측의 피연산자의 값을 변수의 값에서 뺀 후에 다시 변수에 저장
- *=: 우측의 피연산자의 값을 변수의 값과 곱한 후에 다시 변수에 저장
- /=: 우측의 피연산자의 값으로 변수의 값을 나눈 후에 다시 변수에 저장
- %=: 우측의 피연산자의 값으로 변수의 값을 나눈 후에 나머지를 변수에 저장
- &=: 우측의 피연산자의 값으로 변수의 값을 & 연산 후 결과를 변수에 저장
- |=: 우측의 피연산자의 값과 변수의 값을 ^ 연산 후 결과를 변수에 저장
- <<=: 우측의 피연산자의 값과 변수의 값을 << 연산 후 결과를 변수에 저장
- \>\>=: 우측의 피연산자의 값과 변수의 값을 >> 연산 후 결과를 변수에 저장
- \>\>\>=: 우측의 피연산자의 값과 변수의 값을 \>\>\> 연산 후 결과를 변수에 저장
## 11. 삼항(조건) 연산자
- 삼항 연산자(피연산자? 피연산자: 피연산자)
- true면 콜론 앞 피연산자, false면 콜론 뒤 피연산자
## 12. 연산의 방향과 우선순위
- 덧셈(+), 뺄셈(-) 연산자보다는 곱셈(*), 나눗셈(/) 연산자가 우선 처리
- 우선순위가 같은 연산자들끼리는 연산의 방향에 따라 다름
  - 대부분의 연산자: 왼쪽 --> 오른쪽
  - 대입 연산자, 증감, 부호, 비트, 논리: 왼쪽 <--- 오른쪽
- 우선순위: 증감,부호,비트,논리 > 산술 > 쉬프트 > 비교 > 동등비교 > 논리(& > ^ > | > && > || > ?:) > 대입
- 먼저 처리해야 할 연산을 괄호로 묶는 것을 추천(최우선 순위)
# 1. 인터페이스 역할
- 인터페이스: 두 장치(서로 다른 객체)를 연결하는 접속기
- 객체 a가 인터페이스의 메소드를 호출시, 인터페이스는 객체 b의 메소드를 호출 후 결과를 받아 객체 A로 전달해줌.
- 인터페이스를 거치는 이유: 객체 b가 c로 교체될 때 코드 수정 없이 사용 가능(객체 교체로 인해 다른 결과를 얻게 됨->다형성 구현)
# 2. 인터페이스와 구현 클래스 선언
- `.java`형태로 소스 파일로 작성됨, `.class`형태로 컴파일됨.
## 인터페이스 선언
- class 키워드 대신 interface 키워드를 사용(+접근 제한자)
  - `interface 인터페이스명 { ... } //default 접근제한`
  - `public interface 인터페이스명 { ... } //public 접근제한`
- 중괄호 안에 인터페이스가 가지는 멤버들을 선언
```java
public interface 인터페이스명 {
    //public 상수필드
    //public 추상메소드
    //public 디폴트메소드
    //public 정적메소드
    //private 메소드
    //private 정적메소드
}
```
## 구현 클래스 선언
- 인터페이스를 통해 호출되는 구현 객체(implement)는 인터페이스에 선언된 추상 메소드와 동일한 선언부를 가진 (재정의된) 메소드를 가지고 있어야함.
  - 선언부에 명시: `public class B implements 인터페이스명 { ... }`
    - 해당 클래스를 인터페이스를 통해 사용 가능하다는 표시
    - 인터페이스의 추상 메소드를 재정의한 메소드가 존재한다는 표시
## 변수 선언과 구현 객체 대입
- 인터페이스 또한 하나의 (참조)타입 -> 변수의 타입으로 사용 가능, null 대입 가능
- 인터페이스를 통해 구현 객체를 사용: 인터페이스 변수에 구현 객체(의 번지)를 대입 후 추상 메소드 호출
  - 인터페이스 변수에는 구현 객체로 선언된 객체만 대입 가능.
```java
RemoteControl rc;
RemoteControl rc = null;
rc = new Television();
rc.turnOn();
RemoteControl rc = new Television; //변수 선언과 동시에 구현 객체를 대입 가능
```
- rc 변수에는 RemoteControl을 구현한 어떤 객체든 대입 가능(=교체 가능)
# 3. 상수 필드
- 인터페이스는 `public static final`특성을 갖는 불변의 상수 필드를 멤버로 가질 수 있음.
  - `[public static final] 타입 상수명 = 값;`: 모두 public static final 특성을 갖기 때문에 생략 가능
  - 상수명은 대문자로 작성, 서로 다른 단어로 구성되어 있을 경우 언더바로 연결하는 게 관례
# 4. 추상 메소드
- 인터페이스는 구현 클래스가 재정의해야하는 public 추상 메소드(중괄호를 붙이지 않는 메소드)를 멤버로 가질 수 있음.
  - `[public abstract] 리턴타입 메소드명(매개변수, ...);`: public abstract를 생략하더라도 컴파일과정에서 자동으로 추가됨.
  - 추상메소드: 객체 A에게 인터페이스상의 메소드 호출 방법을 알려주는 역할.
- 인터페이스로 구현 객체 사용
  - `인터페이스 인터페이스변수 = new 구현객체();`: 참조타입 인터페이스 변수는 구현 객체의 번지를 저장
  - 구현 객체가 대입된 인터페이스 변수는 추상 메소드를 호출 가능
# 5. 디폴트 메소드
- 인터페이스에 완전한 실행 코드(실행부가 있음)를 가진 디폴트 메소드를 선언 가능.
  - default 키워드가 붙음: `[public] default 리턴타입 메소드명(매개변수, ...) { ... }`
- 디폴트 메소드는 구현 객체가 필요한 메소드
- 구현 클래스는 디폴트 메소드를 재정의 가능
  - public 접근 제한자를 반드시 붙여야함.
  - default 키워드를 생략해야함.
# 6. 정적 메소드
- 인터페이스에는 정적 메소드를 선언 가능 -> 구현 객체가 없어도 (인터페이스명으로 접근하여) 호출 가능
- public 선언을 생략해도 자동으로 컴파일 과정에서 붙음
- `[public | private] static 리턴타입 메소드명(매개변수, ...) { ... }`
- 정적 메소드의 실행부 작성 시 상수 필드를 제외한 추상메소드, 디폴트메소드, private 메소드 등을 호출 불가
# 7. private 메소드
- 인터페이스의 상수필드, 추상메소드, 디폴트메소드, 정적메소드는 모두 public 접근 제한을 가짐(생략하더라도 컴파일과정에서 붙음) ->외부에서 접근가능
- 인터페이스에 외부에서 접근불가능한 private메소드 선언가능 
  - private 메소드: 구현 객체 필요
  - private 정적 메소드: 구현 객체가 필요x, 디폴트메소드/정적메소드안에서 호출가능
# 8. 다중 인터페이스 구현
- 구현 객체는 여러 개의 인터페이스를 implements할 수 있음.
  - `public class 구현클래스명 implements 인터페이스A, 인터페이스B { //모든 추상 메소드 재정의 }`
  - 인터페이스A와 인터페이스B를 구현한 객체는 두 인터페이스 타입 변수에 각각 대입 가능
    - `인터페이스A 변수 = new 구현클래스명(...);`
    - `인터페이스B 변수 = new 구현클래스명(...);`
# 9. 인터페이스 상속
- 인터페이스도 다른 인터페이스를 상속 가능, 다중 상속 허용
  - `public interface 자식인터페이스 extends 부모인터페이스1, 부모인터페이스2 { ... }`
  - 자식 인터페이스의 구현 클래스가 재정의해야하는 추상 메소드: 자식 인터페이스의 추상 메소드, 부모 인터페이스의 추상 메소드
  - 구현 객체는 자식 및 부모 인터페이스 변수에 대입 가능
    - 자식 인터페이스 변수에 대입되는 경우 자식 및 부모 인터페이스의 추상 메소드를 모두 호출 가능
    - 부모 인터페이스 변수에 대입되는 경우 부모 인터페이스에 선언된 추상 메소드만 호출 가능
# 10. 타입 변환
- 인터페이스 타입 변환은 인터페이스와 구현 클래스 간에 발생.
  - 자동 타입 변환: 인터페이스 변수에 구현객체를 대입하면 구현 객체는 인터페이스 타입으로 자동 타입 변환됨.
  - 강제 타입 변환: 인터페이스 타입을 구현클래스 타입으로 변환 가능
## 자동 타입 변환
- `인터페이스 변수 = 구현객체;`: 구현 객체의 타입이 인터페이스 타입으로 자동 타입 변환이 이루어짐.
  - 부모 클래스가 인터페이스를 구현하고 있다면 자식 클래스도 인터페이스 타입으로 자동 변환될 수 있음
## 강제 타입 변환
- 캐스팅 기호를 사용: `구현클래스 변수 = (구현클래스) 인터페이스변수;`
  - 구현 객체가 인터페이스 타입으로 자동변환되면 인터페이스에 선언된 메소드만 사용 가능
  - 자동 타입 변호나 후에 구현 객체로 구현 클래스의 나머지 메소드를 호출하고 싶다면 캐스팅 기호를 사용하여 강제 타입 변환해야함.
# 11. 다형성
- 현업에서는 상속보다 인터페이스를 통해서 다형성을 구현하는 경우가 더 많음.
- 다형성: 사용방법은 동일하지만 다양한 결과가 나오는 성질
  - 메소드 재정의 + 자동 타입 변환 => 다형성
    - 인터페이스의 추상 메소드는 구현 클래스에서 재정의
    - 구현 객체는 인터페이스 타입으로 자동 타입 변환되고, 인터페이스 메소드 호출시 구현 객체의 재정의된 메소드가 호출됨으로써 다형성의 결과가 나옴.
## 필드의 다형성
```java
public class Car {
  Tire tire1 = new HankookTire();
  Tire tire2 = new KumhoTire();
}

Car myCar = new Car();
myCar.tire1 = new KumhoTire();
<<<<<<< HEAD
```
## 매개변수의 다형성
- 메소드 호출 시 매개값을 다양화하기 위해
  - 매개변수 타입을 부모 타입으로 선언, 호출 시 자식 객체 대입
  - 매개변수 타입을 인터페이스로 선언, 호출 시 구현 객체 대입
```java
public interface Vehicle {
    void run();
}

public class Driver {
    void drive(Vehicle vehicle) {
        vehicle.run();
    }
}

public class Bus implements Vehicle {
    void run() {
        //재정의
    }
}

Driver driver = new Driver();
Bus bus = new Bus();
driver.drive(bus);
```
# 12. 객체 타입 확인
- 상속에서 객체 타입을 확인하기 위해 instanceof 연산자를 사용
- 인터페이스에서도 인터페이스변수에 대입된 객체를 확인하기 위해 instanceof 연산자를 사용
  - ex. 메소드의 매개변수가 인터페이스 타입 -> 메소드 호출 시 매개값은 해당 인터페이스를 구현하는 모든 객체가 될 수 있음 -> 매개값이 특정 구현 객체일 경우에만 강제 타입 변환을 원하는 경우
  ```java
  public void method(Vehicle vehicle) {
      if(vehicle instanceof Bus) {
          Bus bus = (Bus) vehicle;
      }
  }
  //Java 12부터는 instanceof 연산 결과가 true인 경우 우측 타입 변수를 사용 가능
  if(vehicle instanceof Bus bus) {
      //bus 변수 사용
  }
  ```
# 13. 봉인된 인터페이스
- 무분별한 자식 인터페이스 생성을 방지하기 위해 봉인된 인터페이스를 사용 가능
- `public sealed interface InterfaceA permits InterfaceB { ... }`: interfaceA의 자식 인터페이스는 interfaceB만 가능
- `public non-sealed interface InterfaceB extends InterfaceA { ... }`: interfaceA를 상속하는 interfaceB는 `non-sealed` 키워드로 선언하여 봉인을 해제하거나 `sealed` 키워드로 봉인 인터페이스로 선언
  - 봉인을 해제한 경우 다른 자식 인터페이스를 만들 수 있음. `public interface InterfaceC extends InterfaceB { ... }`
=======
```
>>>>>>> d7a4aba8553773cc8b861351342780aae36f9b91
